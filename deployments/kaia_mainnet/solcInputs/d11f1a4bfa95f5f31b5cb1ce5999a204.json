{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.2) (utils/Base64.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/elementa/nftFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\nimport {modifiersFacet} from \"../shared/utils/modifiersFacet.sol\";\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {ElementaItem, EquipmentType, ElementaNFT, GradeOutline} from \"../shared/storage/structs/AppStorage.sol\";\nimport {IERC721} from \"../shared/interfaces/IERC721.sol\";\nimport {svg} from \"../shared/libraries/svg.sol\";\nimport {Metadata, DisplayType} from \"../shared/libraries/Metadata.sol\";\nimport {json} from \"../shared/libraries/json.sol\";\nimport {Solarray} from \"../shared/libraries/Solarray.sol\";\n\nimport {LibString} from \"solady/src/utils/LibString.sol\";\n\ncontract nftFacet is modifiersFacet {\n    using svg for *;\n    using Metadata for *;\n\n    function nft_getUri(uint _tokenId) external view returns (string memory) {\n        string memory metaData = Metadata.base64JsonDataURI(\n            json.objectOf(\n                Solarray.strings(\n                    json.property(\n                        \"name\",\n                        string.concat(\n                            \"Elementa #\",\n                            LibString.toString(_tokenId)\n                        )\n                    ),\n                    json.property(\n                        \"description\",\n                        \"Test Elementa dNFT, for testing\"\n                    ),\n                    json.property(\n                        \"image\",\n                        Metadata.base64SvgDataURI(_generateSVG(_tokenId))\n                    )\n                )\n            )\n        );\n\n        return metaData;\n    }\n\n    function getImage(\n        string memory id,\n        string memory base64Data\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                svg.el(\n                    \"image\",\n                    string.concat(\n                        svg.prop(\"id\", id),\n                        svg.prop(\"width\", \"64\"),\n                        svg.prop(\"height\", \"64\"),\n                        svg.prop(\"transform\", \"translate(-.04 .08)\"),\n                        svg.prop(\"href\", base64Data) // 'href' 속성으로 변경\n                    ),\n                    \"\"\n                )\n            );\n    }\n\n    function getTierOutline(uint _grade) internal view returns (string memory) {\n        return\n            svg.linearGradient(\n                string.concat(\n                    svg.prop(\"id\", \"gradeOutline\"),\n                    svg.prop(\"x1\", \"0%\"),\n                    svg.prop(\"y1\", \"0%\"),\n                    svg.prop(\"x2\", \"100%\"),\n                    svg.prop(\"y2\", \"100%\")\n                ),\n                string.concat(\n                    svg.el(\n                        \"stop\",\n                        string.concat(\n                            svg.prop(\"offset\", \"0%\"),\n                            svg.prop(\n                                \"style\",\n                                // s.gradeOutlines[nft.grade].stopColor\n                                \"stop-color:#afafaf;stop-opacity:1\"\n                            )\n                        ),\n                        svg.el(\n                            \"animate\",\n                            string.concat(\n                                svg.prop(\"attributeName\", \"stop-color\"),\n                                svg.prop(\n                                    \"values\",\n                                    // s.gradeOutlines[nft.grade].animateColors\n                                    \"#afafaf;#d2d4dc;#afafaf\"\n                                ),\n                                svg.prop(\"dur\", \"2s\"),\n                                // svg.prop(\n                                //     \"dur\",\n                                //     s.gradeOutlines[nft.grade].animateDuration\n                                // ),\n                                svg.prop(\"repeatCount\", \"indefinite\")\n                            )\n                        )\n                    ),\n                    svg.el(\n                        \"stop\",\n                        string.concat(\n                            svg.prop(\"offset\", \"100%\"),\n                            svg.prop(\n                                \"style\",\n                                \"stop-color:#afafaf;stop-opacity:1\"\n                            )\n                        ),\n                        svg.el(\n                            \"animate\",\n                            string.concat(\n                                svg.prop(\"attributeName\", \"stop-color\"),\n                                svg.prop(\"values\", \"#afafaf;#d2d4dc;#afafaf\"),\n                                svg.prop(\"dur\", \"2s\"),\n                                svg.prop(\"repeatCount\", \"indefinite\")\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function getBackground(\n        uint _tokenId\n    ) internal view returns (string memory) {\n        return\n            svg.linearGradient(\n                string.concat(\n                    svg.prop(\"id\", \"background\"),\n                    svg.prop(\"x1\", \"0%\"),\n                    svg.prop(\"x2\", \"0%\"),\n                    svg.prop(\"y1\", \"0%\"),\n                    svg.prop(\"y2\", \"100%\")\n                ),\n                string.concat(\n                    svg.el(\n                        \"stop\",\n                        string.concat(\n                            svg.prop(\"offset\", \"0%\"),\n                            svg.prop(\"stop-color\", \"#fffff2\")\n                        ),\n                        \"\"\n                    ),\n                    svg.el(\n                        \"stop\",\n                        string.concat(\n                            svg.prop(\"offset\", \"100%\"),\n                            svg.prop(\"stop-color\", \"#f9f9f9\")\n                        ),\n                        \"\"\n                    )\n                )\n            );\n    }\n\n    function _generateSVG(uint _tokenId) public view returns (string memory) {\n        ElementaNFT memory nft = s.elementaNFTs[_tokenId];\n\n        return\n            string.concat(\n                svg.top(\n                    svg.prop(\"viewBox\", \"0 0 250 250\"),\n                    string.concat(\n                        // Defining gradients\n                        svg.el(\n                            \"defs\",\n                            \"\",\n                            string.concat(\n                                getTierOutline(nft.grade),\n                                getBackground(_tokenId)\n                            )\n                        ),\n                        // Defining background and border\n                        svg.rect(\n                            string.concat(\n                                svg.prop(\"width\", \"100%\"),\n                                svg.prop(\"height\", \"100%\"),\n                                svg.prop(\"fill\", svg.getDefURL(\"background\")),\n                                svg.prop(\n                                    \"stroke\",\n                                    svg.getDefURL(\"gradeOutline\")\n                                ),\n                                svg.prop(\"stroke-width\", \"7\")\n                            ),\n                            \"\"\n                        ),\n                        svg.el(\n                            \"g\",\n                            svg.prop(\"transform\", \"translate(62.5, 55.5)\"), // (250 - 64) / 2 = 93, 이미지를 중앙으로 위치\n                            string.concat(\n                                // outline\n                                getImage(\n                                    \"_charOutline_xA0_image\",\n                                    \"data:image/svg;base64,iVBORw0KGgoAAAANSUhEUgAAAEEAAABBCAYAAACO98lFAAAACXBIWXMAAAsSAAALEgHS3X78AAACh0lEQVR4nO2bMW/TQBSAv5QgUTXJiLJ5YiFTl4xIwIDIws7KwL/I0N/AylrxC9igUsduDO2CGLohj21BQkI1Az3LNk6a+t57vqD3TVFsOXffvffOOZ8HJEY2nRfN786/nww0f1P14lWanWt2rHr86OwQgFcf3gJwcXCpKmJH68JVsum8mCzHTJbjsoNtI350dlgeb7uGVvuGWhdu4+rhb+BvZ58+fr3yvOef3wAwMmqeqYQqNyL+SYFSQF5vmmY6mNSEEMqT5biMhk/P3pfRsPNut3Z+VYB2PQCjmhA6cXFwySgfMsqH5YgHwvdNARaYzQ5QL26T5bh2bFWHtaMAjCVUCTNGwCLsV2GSDqnjEugpHW678bFOC3MJm975WYrobXY4Pf/Yes4sW5SfrUSY/4Fa1fkmljLUJWwy+uuYZQsG8PXn9a/9PP/yQ7RxN5jNDl0EBO7dHz56+eLJlWBzaqhGwl1TYB2zbMFo7wGn347F26wiQbLzVbTqhN8soRAJWlFQJUSEVDSISsim80Kz801m2UJEhMjKkub6nwWiNcEyCgLZdF7EDsJWF0Yp6dH5ZFEIbyO2UG51JEjhEohIhxTSoEnXtDCNhOsizZnUVMKgv8XttdhKSNNBt6FJsR4EutQFnx1wCYBLAFwC4BIAlwC4BMAlAC4BcAmASwAiJVSfCKVA1/Z0WnIPf05SXGrvss7o6YCAhFRSIqYdIpGQioiu/BfpEDsIUc8iUyiQEk+oxSKhj5SQ+k2Rpc/YzVldkNyjIL4/IXy22KQBCUoIaK5GS+9SAeXZQbpOaNUdky18EBcV2rtbTd+BCmwipDnqW/8iGMTdS2z93uY2NhHS16tAjuM4DvAHUwT634NLx7kAAAAASUVORK5CYII=\"\n                                ),\n                                // arm\n                                getImage(\n                                    \"_charAmr_xA0_image\",\n                                    \"data:image/svg;base64,iVBORw0KGgoAAAANSUhEUgAAAEEAAABBCAYAAACO98lFAAAACXBIWXMAAAsSAAALEgHS3X78AAAA5ElEQVR4nO3WsQ3CMBCF4UuWSCQKM4VbxmAYaLIALJAZaCmggYICUaWnQKIIJXWUHE2ygG1igv6vj+/07mxFBAAAAAAAAAAAAAAAAAAAAAAwbSa3anKrsfsIIY3dQCg+Q/EO4Re2wbcHrxDKXRmkiRAe9TVx/Xby1yHEALxDGLYhtsOlcg4j2CbEuBJDTd9BBAlhbmYhjolW2zmEJHV+h77GtSfnELRTbZtORETW20Ikkcb1LA/P1aboRETaphVVfY9a/Xiuliaztcmtmsze96fbYtQGeia3r/5HqYtRHwAA4O99AKTCO8eSAA8eAAAAAElFTkSuQmCC\"\n                                ),\n                                // leg\n                                getImage(\n                                    \"_leg_xA0_image\",\n                                    \"data:image/svg;base64,iVBORw0KGgoAAAANSUhEUgAAAEEAAABBCAYAAACO98lFAAAACXBIWXMAAAsSAAALEgHS3X78AAAAfUlEQVR4nO3UsQ3CMBAF0B+moMsWjO0l0rEFXbaABksBhEik2ID0XmfrdKe74icAAAAAAAAAAAAAAAAAAPBPhl6DxuPpunxf5vPb2Vtq93Bo2fxZmUrKVJK8LlrV/2Vta12PUH1artfy1VeO8GscIR2DMXnMgbXB2DoUubsB+bMfnf2sWikAAAAASUVORK5CYII=\"\n                                ),\n                                // eyes\n                                getImage(\n                                    \"_eyes_xA0_image\",\n                                    \"data:image/svg;base64,iVBORw0KGgoAAAANSUhEUgAAAEEAAABBCAYAAACO98lFAAAACXBIWXMAAAsSAAALEgHS3X78AAAAeklEQVR4nO3UsQ3CMBBA0YAYwhGFEUOYKvtLbEHHCiksU5kGAUpkRyneq665f648DAAAAAAAAADQy6FnPIZU6vx43lffatXZXAypxJBKlfNc/m99ynl+N2qz9VuPrYPfXM/TpntLnHofuIy3XTR+8ScAAAAAAAAAQFcvmTMvYSxs+bMAAAAASUVORK5CYII=\"\n                                ),\n                                // mouth\n                                getImage(\n                                    \"_mouth_xA0_image\",\n                                    \"data:image/svg;base64,iVBORw0KGgoAAAANSUhEUgAAAEEAAABBCAYAAACO98lFAAAACXBIWXMAAAsSAAALEgHS3X78AAAASElEQVR4nO3PoQ3AIAAEQLoFji26v2YLHFuARWBICk3InXzz/yEAAAAAAAAAAAC3S/FtK/lOz+nC0exwqfnXTQAAAAAAAABf6ftjBtraAp8tAAAAAElFTkSuQmCC\"\n                                )\n                            )\n                        ),\n                        svg.text(\n                            string.concat(\n                                svg.prop(\"x\", \"5%\"),\n                                svg.prop(\"y\", \"85%\"),\n                                svg.prop(\"font-family\", \"Arial\"),\n                                svg.prop(\"font-size\", \"15\"),\n                                svg.prop(\"fill\", \"#000\"),\n                                svg.prop(\"text-anchor\", \"start\")\n                            ),\n                            string.concat(\n                                \"ElementaNFT #\",\n                                LibString.toString(_tokenId)\n                            )\n                        ),\n                        svg.text(\n                            string.concat(\n                                svg.prop(\"x\", \"5%\"),\n                                svg.prop(\"y\", \"90%\"),\n                                svg.prop(\"font-family\", \"Arial\"),\n                                svg.prop(\"font-size\", \"10\"),\n                                svg.prop(\"fill\", \"#000\"),\n                                svg.prop(\"text-anchor\", \"start\")\n                            ),\n                            string.concat(\n                                \"Level: \",\n                                LibString.toString(\n                                    s.elementaNFTs[_tokenId].level\n                                )\n                            )\n                        ),\n                        svg.text(\n                            string.concat(\n                                svg.prop(\"x\", \"5%\"),\n                                svg.prop(\"y\", \"95%\"),\n                                svg.prop(\"font-family\", \"Arial\"),\n                                svg.prop(\"font-size\", \"10\"),\n                                svg.prop(\"fill\", \"#000\"),\n                                svg.prop(\"text-anchor\", \"start\")\n                            ),\n                            string.concat(\n                                \"&#128150; x \",\n                                LibString.toString(\n                                    s.elementaNFTs[_tokenId].heartPoint\n                                )\n                            )\n                        )\n                    )\n                )\n            );\n    }\n\n    function _getEquipmentSVG(\n        uint _tokenId\n    ) internal view returns (ElementaNFT memory) {\n        return s.elementaNFTs[_tokenId];\n    }\n\n    function _updateUri(uint _tokenId) public {\n        IERC721 nft = IERC721(s.contracts[\"nft\"]);\n        nft._update_metadata_uri(_tokenId);\n    }\n}\n"
    },
    "contracts/shared/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/shared/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\n//import \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\n/* interface IERC721 is IERC165 { */\ninterface IERC721 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(\n        address indexed from,\n        address indexed to,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed approved,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(\n        uint256 tokenId\n    ) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n\n    function burn(uint256 _tokenId) external;\n\n    function safeMintByMinter(address _to) external;\n\n    function nextTokenId() external view returns (uint256);\n\n    function safeMint(address to, string memory uri) external returns (uint);\n\n    function diamondMint(address to, uint256 tokenId) external;\n\n    function _update_metadata_uri(uint _tokenId) external;\n}\n"
    },
    "contracts/shared/libraries/json.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {LibString} from \"solady/src/utils/LibString.sol\";\n\n/**\n * @title JSON\n * @author emo.eth\n * @notice TODO: overrides for common types that automatically stringify\n */\nlibrary json {\n    string private constant NULL = \"\";\n\n    using LibString for string;\n\n    /**\n     * @notice enclose a string in {braces}\n     *         Note: does not escape quotes in value\n     * @param  value string to enclose in braces\n     * @return string of {value}\n     */\n    function object(string memory value) internal pure returns (string memory) {\n        return string.concat(\"{\", value, \"}\");\n    }\n\n    /**\n     * @notice enclose a string in [brackets]\n     *         Note: does not escape quotes in value\n     * @param value string to enclose in brackets\n     * @return string of [value]\n     */\n    function array(string memory value) internal pure returns (string memory) {\n        return string.concat(\"[\", value, \"]\");\n    }\n\n    /**\n     * @notice enclose name and value with quotes, and place a colon \"between\":\"them\".\n     *         Note: escapes quotes in name and value\n     * @param name name of property\n     * @param value value of property\n     * @return string of \"name\":\"value\"\n     */\n    function property(\n        string memory name,\n        string memory value\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                '\"',\n                name.escapeJSON(),\n                '\":\"',\n                value.escapeJSON(),\n                '\"'\n            );\n    }\n\n    /**\n     * @notice enclose name with quotes, but not rawValue, and place a colon \"between\":them\n     *         Note: escapes quotes in name, but not value (which may itself be a JSON object, array, etc)\n     * @param name name of property\n     * @param rawValue raw value of property, which will not be enclosed in quotes\n     * @return string of \"name\":value\n     */\n    function rawProperty(\n        string memory name,\n        string memory rawValue\n    ) internal pure returns (string memory) {\n        return string.concat('\"', name.escapeJSON(), '\":', rawValue);\n    }\n\n    /**\n     * @notice comma-join an array of properties and {\"enclose\":\"them\",\"in\":\"braces\"}\n     *         Note: does not escape quotes in properties, as it assumes they are already escaped\n     * @param properties array of '\"name\":\"value\"' properties to join\n     * @return string of {\"name\":\"value\",\"name\":\"value\",...}\n     */\n    function objectOf(\n        string[] memory properties\n    ) internal pure returns (string memory) {\n        return object(_commaJoin(properties));\n    }\n\n    /**\n     * @notice comma-join an array of values and enclose them [in,brackets]\n     *         Note: does not escape quotes in values, as it assumes they are already escaped\n     * @param values array of values to join\n     * @return string of [value,value,...]\n     */\n    function arrayOf(\n        string[] memory values\n    ) internal pure returns (string memory) {\n        return array(_commaJoin(values));\n    }\n\n    /**\n     * @notice comma-join two arrays of values and [enclose,them,in,brackets]\n     *         Note: does not escape quotes in values, as it assumes they are already escaped\n     * @param values1 first array of values to join\n     * @param values2 second array of values to join\n     * @return string of [values1_0,values1_1,values2_0,values2_1...]\n     */\n    function arrayOf(\n        string[] memory values1,\n        string[] memory values2\n    ) internal pure returns (string memory) {\n        if (values1.length == 0) {\n            return arrayOf(values2);\n        } else if (values2.length == 0) {\n            return arrayOf(values1);\n        }\n        return\n            array(string.concat(_commaJoin(values1), \",\", _commaJoin(values2)));\n    }\n\n    /**\n     * @notice enclose a string in double \"quotes\", escaping any existing quotes\n     * @param str string to enclose in quotes\n     * @return string of \"value\"\n     */\n    function quote(string memory str) internal pure returns (string memory) {\n        return string.concat('\"', str.escapeJSON(), '\"');\n    }\n\n    /**\n     * @notice enclose each string in an array in double \"quotes\", escaping any existing quotes\n     * @param strs array of strings, each to escape and enclose in quotes\n     */\n    function quote(\n        string[] memory strs\n    ) internal pure returns (string[] memory) {\n        string[] memory result = new string[](strs.length);\n        for (uint256 i = 0; i < strs.length; ) {\n            result[i] = quote(strs[i]);\n            unchecked {\n                ++i;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @notice comma-join an array of strings\n     * @param values array of strings to join\n     * @return string of value,value,...\n     */\n    function _commaJoin(\n        string[] memory values\n    ) internal pure returns (string memory) {\n        return _join(values, \",\");\n    }\n\n    /**\n     * @notice join two strings with a comma\n     * @param value1 first string\n     * @param value2 second string\n     * @return string of value1,value2\n     */\n    function _commaJoin(\n        string memory value1,\n        string memory value2\n    ) internal pure returns (string memory) {\n        return string.concat(value1, \",\", value2);\n    }\n\n    /**\n     * @notice join an array of strings with a specified separator\n     * @param values array of strings to join\n     * @param separator separator to join with\n     * @return string of value<separator>value<separator>...\n     */\n    function _join(\n        string[] memory values,\n        string memory separator\n    ) internal pure returns (string memory) {\n        if (values.length == 0) {\n            return NULL;\n        }\n        string memory result = values[0];\n        for (uint256 i = 1; i < values.length; ++i) {\n            result = string.concat(result, separator, values[i]);\n        }\n        return result;\n    }\n}\n"
    },
    "contracts/shared/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        DiamondStorage storage ds = diamondStorage();\n        address previousOwner = ds.contractOwner;\n        ds.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();        \n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);            \n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }    \n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {        \n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");        \n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/shared/libraries/LibEnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/shared/libraries/LibUintQueueLibrary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary UintQueueLibrary {\n    struct UintQueue {\n        uint256[] data;\n    }\n\n    // Add an element to the front of the queue\n    function addFront(UintQueue storage queue, uint256 element) internal {\n        queue.data.push(element); // Add element at the end\n        uint256 len = queue.data.length;\n        for (uint256 i = len - 1; i > 0; i--) {\n            queue.data[i] = queue.data[i - 1];\n        }\n        queue.data[0] = element; // Move element to the front\n    }\n\n    // Add an element to the back of the queue\n    function addBack(UintQueue storage queue, uint256 element) internal {\n        queue.data.push(element);\n    }\n\n    // Add an element to the middle of the queue at the specified index\n    function addMiddle(\n        UintQueue storage queue,\n        uint256 element,\n        uint256 index\n    ) internal {\n        require(index <= queue.data.length, \"Index out of bounds\");\n\n        queue.data.push(element); // Add element at the end\n        for (uint256 i = queue.data.length - 1; i > index; i--) {\n            queue.data[i] = queue.data[i - 1];\n        }\n        queue.data[index] = element; // Move element to the middle\n    }\n\n    // Remove an element from the front of the queue\n    function removeFront(UintQueue storage queue) internal returns (uint256) {\n        require(queue.data.length > 0, \"Queue is empty\");\n\n        uint256 element = queue.data[0];\n        for (uint256 i = 0; i < queue.data.length - 1; i++) {\n            queue.data[i] = queue.data[i + 1];\n        }\n        queue.data.pop();\n        return element;\n    }\n\n    // Remove an element from the back of the queue\n    function removeBack(UintQueue storage queue) internal returns (uint256) {\n        require(queue.data.length > 0, \"Queue is empty\");\n\n        uint256 element = queue.data[queue.data.length - 1];\n        queue.data.pop();\n        return element;\n    }\n\n    // Remove an element from the middle of the queue at the specified index\n    function removeMiddle(\n        UintQueue storage queue,\n        uint256 index\n    ) internal returns (uint256) {\n        require(index < queue.data.length, \"Index out of bounds\");\n\n        uint256 element = queue.data[index];\n        for (uint256 i = index; i < queue.data.length - 1; i++) {\n            queue.data[i] = queue.data[i + 1];\n        }\n        queue.data.pop();\n        return element;\n    }\n\n    // Get the element at the front of the queue\n    function front(UintQueue storage queue) internal view returns (uint256) {\n        require(queue.data.length > 0, \"Queue is empty\");\n        return queue.data[0];\n    }\n\n    // Get the element at the back of the queue\n    function back(UintQueue storage queue) internal view returns (uint256) {\n        require(queue.data.length > 0, \"Queue is empty\");\n        return queue.data[queue.data.length - 1];\n    }\n\n    // Check if the queue is empty\n    function isEmpty(UintQueue storage queue) internal view returns (bool) {\n        return queue.data.length == 0;\n    }\n\n    // Get the number of elements in the queue\n    function length(UintQueue storage queue) internal view returns (uint256) {\n        return queue.data.length;\n    }\n\n    // Get the element at a specific index in the queue\n    function get(\n        UintQueue storage queue,\n        uint256 index\n    ) internal view returns (uint256) {\n        require(index < queue.data.length, \"Index out of bounds\");\n        return queue.data[index];\n    }\n\n    // Get the elements from the specified range of indices in the queue\n    function getRange(\n        UintQueue storage queue,\n        uint256 fromIndex,\n        uint256 toIndex\n    ) internal view returns (uint256[] memory) {\n        require(fromIndex <= toIndex, \"Invalid index range\");\n        require(toIndex < queue.data.length, \"Index out of bounds\");\n\n        uint256 length = toIndex - fromIndex + 1;\n        uint256[] memory range = new uint256[](length);\n        for (uint256 i = fromIndex; i <= toIndex; i++) {\n            range[i - fromIndex] = queue.data[i];\n        }\n        return range;\n    }\n\n    // Get the elements from the specified range of indices in the queue in reverse order\n    function getRangeReverse(\n        UintQueue storage queue,\n        uint256 fromIndex,\n        uint256 toIndex\n    ) internal view returns (uint256[] memory) {\n        require(fromIndex <= toIndex, \"Invalid index range\");\n        require(toIndex < queue.data.length, \"Index out of bounds\");\n\n        uint256 length = toIndex - fromIndex + 1;\n        uint256[] memory range = new uint256[](length);\n        for (uint256 i = 0; i < length; i++) {\n            range[i] = queue.data[toIndex - i];\n        }\n        return range;\n    }\n\n    function findIndex(\n        UintQueue storage queue,\n        uint256 element\n    ) internal view returns (int256) {\n        for (uint256 i = 0; i < queue.data.length; i++) {\n            if (queue.data[i] == element) {\n                return int256(i);\n            }\n        }\n        return -1; // Return -1 if the element is not found\n    }\n\n    function removeElement(\n        UintQueue storage queue,\n        uint256 element\n    ) internal returns (bool) {\n        int256 index = findIndex(queue, element);\n        if (index == -1) {\n            return false; // Element not found\n        }\n\n        for (uint256 i = uint256(index); i < queue.data.length - 1; i++) {\n            queue.data[i] = queue.data[i + 1];\n        }\n        queue.data.pop();\n        return true;\n    }\n}"
    },
    "contracts/shared/libraries/Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\nimport {json} from \"./json.sol\";\nimport {LibString} from \"solady/src/utils/LibString.sol\";\nimport {Solarray} from \"./Solarray.sol\";\nimport {Base64} from \"solady/src/utils/Base64.sol\";\n\nenum DisplayType {\n    String,\n    Number,\n    Date,\n    BoostPercent,\n    BoostNumber,\n    Hidden\n}\n\nlibrary Metadata {\n    string private constant NULL = \"\";\n\n    using LibString for string;\n\n    function attribute(\n        string memory traitType,\n        string memory value\n    ) internal pure returns (string memory) {\n        return\n            json.objectOf(\n                Solarray.strings(\n                    json.property(\"trait_type\", traitType),\n                    json.property(\"value\", value)\n                )\n            );\n    }\n\n    function attribute(\n        string memory traitType,\n        string memory value,\n        DisplayType displayType\n    ) internal pure returns (string memory) {\n        return\n            json.objectOf(\n                Solarray.strings(\n                    json.property(\"trait_type\", traitType),\n                    json.property(\"value\", value),\n                    json.property(\"display_type\", toString(displayType))\n                )\n            );\n    }\n\n    function toString(\n        DisplayType displayType\n    ) internal pure returns (string memory) {\n        if (displayType == DisplayType.String) {\n            return \"string\";\n        } else if (displayType == DisplayType.Number) {\n            return \"number\";\n        } else if (displayType == DisplayType.Date) {\n            return \"date\";\n        } else if (displayType == DisplayType.BoostNumber) {\n            return \"boost_number\";\n        } else if (displayType == DisplayType.BoostPercent) {\n            return \"boost_percent\";\n        } else {\n            return \"hidden\";\n        }\n    }\n\n    function dataURI(\n        string memory dataType,\n        string memory encoding,\n        string memory content\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\n                \"data:\",\n                dataType,\n                \";\",\n                bytes(encoding).length > 0\n                    ? string.concat(encoding, \",\")\n                    : NULL,\n                content\n            );\n    }\n\n    function dataURI(\n        string memory dataType,\n        string memory content\n    ) internal pure returns (string memory) {\n        return dataURI(dataType, NULL, content);\n    }\n\n    function jsonDataURI(\n        string memory content,\n        string memory encoding\n    ) internal pure returns (string memory) {\n        return dataURI(\"application/json\", encoding, content);\n    }\n\n    function jsonDataURI(\n        string memory content\n    ) internal pure returns (string memory) {\n        return jsonDataURI(content, NULL);\n    }\n\n    function base64JsonDataURI(\n        string memory content\n    ) internal pure returns (string memory) {\n        return jsonDataURI(Base64.encode(bytes(content)), \"base64\");\n    }\n\n    function svgDataURI(\n        string memory content,\n        string memory encoding,\n        bool escape\n    ) internal pure returns (string memory) {\n        string memory uri = dataURI(\"image/svg+xml\", encoding, content);\n\n        if (escape) {\n            return uri.escapeJSON();\n        } else {\n            return uri;\n        }\n    }\n\n    function svgDataURI(\n        string memory content\n    ) internal pure returns (string memory) {\n        return svgDataURI(content, \"utf8\", true);\n    }\n\n    function base64SvgDataURI(\n        string memory content\n    ) internal pure returns (string memory) {\n        return svgDataURI(Base64.encode(bytes(content)), \"base64\", false);\n    }\n}\n"
    },
    "contracts/shared/libraries/Solarray.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2 <0.9.0;\n\nlibrary Solarray {\n    \n    function uint8s(uint8 a) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b,uint8 c) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b,uint8 c,uint8 d) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b,uint8 c,uint8 d,uint8 e) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b,uint8 c,uint8 d,uint8 e,uint8 f) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint8s(uint8 a,uint8 b,uint8 c,uint8 d,uint8 e,uint8 f,uint8 g) internal pure returns (uint8[] memory) {\n        uint8[] memory arr = new uint8[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b,uint16 c) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b,uint16 c,uint16 d) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b,uint16 c,uint16 d,uint16 e) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b,uint16 c,uint16 d,uint16 e,uint16 f) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint16s(uint16 a,uint16 b,uint16 c,uint16 d,uint16 e,uint16 f,uint16 g) internal pure returns (uint16[] memory) {\n        uint16[] memory arr = new uint16[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b,uint32 c) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b,uint32 c,uint32 d) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b,uint32 c,uint32 d,uint32 e) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b,uint32 c,uint32 d,uint32 e,uint32 f) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint32s(uint32 a,uint32 b,uint32 c,uint32 d,uint32 e,uint32 f,uint32 g) internal pure returns (uint32[] memory) {\n        uint32[] memory arr = new uint32[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n    \n    function uint40s(uint40 a) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b,uint40 c) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b,uint40 c,uint40 d) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b,uint40 c,uint40 d,uint40 e) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b,uint40 c,uint40 d,uint40 e,uint40 f) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint40s(uint40 a,uint40 b,uint40 c,uint40 d,uint40 e,uint40 f,uint40 g) internal pure returns (uint40[] memory) {\n        uint40[] memory arr = new uint40[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n    function uint64s(uint64 a) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b,uint64 c) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b,uint64 c,uint64 d) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b,uint64 c,uint64 d,uint64 e) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b,uint64 c,uint64 d,uint64 e,uint64 f) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint64s(uint64 a,uint64 b,uint64 c,uint64 d,uint64 e,uint64 f,uint64 g) internal pure returns (uint64[] memory) {\n        uint64[] memory arr = new uint64[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b,uint128 c) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b,uint128 c,uint128 d) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b,uint128 c,uint128 d,uint128 e) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b,uint128 c,uint128 d,uint128 e,uint128 f) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint128s(uint128 a,uint128 b,uint128 c,uint128 d,uint128 e,uint128 f,uint128 g) internal pure returns (uint128[] memory) {\n        uint128[] memory arr = new uint128[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b,uint256 c) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b,uint256 c,uint256 d) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b,uint256 c,uint256 d,uint256 e) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b,uint256 c,uint256 d,uint256 e,uint256 f) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function uint256s(uint256 a,uint256 b,uint256 c,uint256 d,uint256 e,uint256 f,uint256 g) internal pure returns (uint256[] memory) {\n        uint256[] memory arr = new uint256[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int8s(int8 a) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b,int8 c) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b,int8 c,int8 d) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b,int8 c,int8 d,int8 e) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b,int8 c,int8 d,int8 e,int8 f) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int8s(int8 a,int8 b,int8 c,int8 d,int8 e,int8 f,int8 g) internal pure returns (int8[] memory) {\n        int8[] memory arr = new int8[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int16s(int16 a) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b,int16 c) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b,int16 c,int16 d) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b,int16 c,int16 d,int16 e) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b,int16 c,int16 d,int16 e,int16 f) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int16s(int16 a,int16 b,int16 c,int16 d,int16 e,int16 f,int16 g) internal pure returns (int16[] memory) {\n        int16[] memory arr = new int16[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int32s(int32 a) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b,int32 c) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b,int32 c,int32 d) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b,int32 c,int32 d,int32 e) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b,int32 c,int32 d,int32 e,int32 f) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int32s(int32 a,int32 b,int32 c,int32 d,int32 e,int32 f,int32 g) internal pure returns (int32[] memory) {\n        int32[] memory arr = new int32[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int64s(int64 a) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b,int64 c) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b,int64 c,int64 d) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b,int64 c,int64 d,int64 e) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b,int64 c,int64 d,int64 e,int64 f) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int64s(int64 a,int64 b,int64 c,int64 d,int64 e,int64 f,int64 g) internal pure returns (int64[] memory) {\n        int64[] memory arr = new int64[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int128s(int128 a) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b,int128 c) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b,int128 c,int128 d) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b,int128 c,int128 d,int128 e) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b,int128 c,int128 d,int128 e,int128 f) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int128s(int128 a,int128 b,int128 c,int128 d,int128 e,int128 f,int128 g) internal pure returns (int128[] memory) {\n        int128[] memory arr = new int128[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function int256s(int256 a) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b,int256 c) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b,int256 c,int256 d) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b,int256 c,int256 d,int256 e) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b,int256 c,int256 d,int256 e,int256 f) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function int256s(int256 a,int256 b,int256 c,int256 d,int256 e,int256 f,int256 g) internal pure returns (int256[] memory) {\n        int256[] memory arr = new int256[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b,bytes1 c) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b,bytes1 c,bytes1 d) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b,bytes1 c,bytes1 d,bytes1 e) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b,bytes1 c,bytes1 d,bytes1 e,bytes1 f) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytes1s(bytes1 a,bytes1 b,bytes1 c,bytes1 d,bytes1 e,bytes1 f,bytes1 g) internal pure returns (bytes1[] memory) {\n        bytes1[] memory arr = new bytes1[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b,bytes8 c) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b,bytes8 c,bytes8 d) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b,bytes8 c,bytes8 d,bytes8 e) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b,bytes8 c,bytes8 d,bytes8 e,bytes8 f) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytes8s(bytes8 a,bytes8 b,bytes8 c,bytes8 d,bytes8 e,bytes8 f,bytes8 g) internal pure returns (bytes8[] memory) {\n        bytes8[] memory arr = new bytes8[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b,bytes16 c) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b,bytes16 c,bytes16 d) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b,bytes16 c,bytes16 d,bytes16 e) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b,bytes16 c,bytes16 d,bytes16 e,bytes16 f) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytes16s(bytes16 a,bytes16 b,bytes16 c,bytes16 d,bytes16 e,bytes16 f,bytes16 g) internal pure returns (bytes16[] memory) {\n        bytes16[] memory arr = new bytes16[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b,bytes20 c) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b,bytes20 c,bytes20 d) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b,bytes20 c,bytes20 d,bytes20 e) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b,bytes20 c,bytes20 d,bytes20 e,bytes20 f) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytes20s(bytes20 a,bytes20 b,bytes20 c,bytes20 d,bytes20 e,bytes20 f,bytes20 g) internal pure returns (bytes20[] memory) {\n        bytes20[] memory arr = new bytes20[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b,bytes32 c) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b,bytes32 c,bytes32 d) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b,bytes32 c,bytes32 d,bytes32 e) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b,bytes32 c,bytes32 d,bytes32 e,bytes32 f) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytes32s(bytes32 a,bytes32 b,bytes32 c,bytes32 d,bytes32 e,bytes32 f,bytes32 g) internal pure returns (bytes32[] memory) {\n        bytes32[] memory arr = new bytes32[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b,bytes memory c) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b,bytes memory c,bytes memory d) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b,bytes memory c,bytes memory d,bytes memory e) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b,bytes memory c,bytes memory d,bytes memory e,bytes memory f) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bytess(bytes memory a,bytes memory b,bytes memory c,bytes memory d,bytes memory e,bytes memory f,bytes memory g) internal pure returns (bytes[] memory) {\n        bytes[] memory arr = new bytes[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function addresses(address a) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function addresses(address a,address b) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function addresses(address a,address b,address c) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function addresses(address a,address b,address c,address d) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function addresses(address a,address b,address c,address d,address e) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function addresses(address a,address b,address c,address d,address e,address f) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function addresses(address a,address b,address c,address d,address e,address f,address g) internal pure returns (address[] memory) {\n        address[] memory arr = new address[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function bools(bool a) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b,bool c) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b,bool c,bool d) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b,bool c,bool d,bool e) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b,bool c,bool d,bool e,bool f) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function bools(bool a,bool b,bool c,bool d,bool e,bool f,bool g) internal pure returns (bool[] memory) {\n        bool[] memory arr = new bool[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n\n    function strings(string memory a) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](1);\n\t\tarr[0] = a;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](2);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b,string memory c) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](3);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b,string memory c,string memory d) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](4);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b,string memory c,string memory d,string memory e) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](5);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b,string memory c,string memory d,string memory e,string memory f) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](6);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n        return arr;\n    }\n\n\n    function strings(string memory a,string memory b,string memory c,string memory d,string memory e,string memory f,string memory g) internal pure returns (string[] memory) {\n        string[] memory arr = new string[](7);\n\t\tarr[0] = a;\n\t\tarr[1] = b;\n\t\tarr[2] = c;\n\t\tarr[3] = d;\n\t\tarr[4] = e;\n\t\tarr[5] = f;\n\t\tarr[6] = g;\n        return arr;\n    }\n\n}"
    },
    "contracts/shared/libraries/svg.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.12;\n\nimport {LibString} from \"solady/src/utils/LibString.sol\";\n\nlibrary svg {\n    using LibString for uint256;\n\n    // used to simulate empty strings\n    string internal constant NULL = \"\";\n\n    function top(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return svg_(true, props, children);\n    }\n\n    function svg_(\n        bool includeXmlns,\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        if (includeXmlns) {\n            return\n                el(\n                    \"svg\",\n                    string.concat('xmlns=\"http://www.w3.org/2000/svg\" ', props),\n                    children\n                );\n        } else {\n            return el(\"svg\", props, children);\n        }\n    }\n\n    function g(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"g\", props, children);\n    }\n\n    function path(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"path\", props, children);\n    }\n\n    function text(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"text\", props, children);\n    }\n\n    function line(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"line\", props, children);\n    }\n\n    function circle(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"circle\", props, children);\n    }\n\n    function circle(string memory props) internal pure returns (string memory) {\n        return el(\"circle\", props);\n    }\n\n    function rect(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"rect\", props, children);\n    }\n\n    function rect(string memory props) internal pure returns (string memory) {\n        return el(\"rect\", props);\n    }\n\n    function filter(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"filter\", props, children);\n    }\n\n    function cdata(\n        string memory content\n    ) internal pure returns (string memory) {\n        return string.concat(\"<![CDATA[\", content, \"]]>\");\n    }\n\n    /* GRADIENTS */\n    function radialGradient(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"radialGradient\", props, children);\n    }\n\n    function linearGradient(\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return el(\"linearGradient\", props, children);\n    }\n\n    function gradientStop(\n        uint256 offset,\n        string memory stopColor,\n        string memory props\n    ) internal pure returns (string memory) {\n        return\n            el(\n                \"stop\",\n                string.concat(\n                    prop(\"stop-color\", stopColor),\n                    prop(\"offset\", string.concat(offset.toString(), \"%\")),\n                    props\n                )\n            );\n    }\n\n    function animateTransform(\n        string memory props\n    ) internal pure returns (string memory) {\n        return el(\"animateTransform\", props);\n    }\n\n    function image(\n        string memory href,\n        string memory props\n    ) internal pure returns (string memory) {\n        return el(\"image\", string.concat(prop(\"href\", href), props));\n    }\n\n    /* COMMON */\n    // A generic element, can be used to construct any SVG (or HTML) element\n    function el(\n        string memory tag,\n        string memory props,\n        string memory children\n    ) internal pure returns (string memory) {\n        return\n            string.concat(\"<\", tag, \" \", props, \">\", children, \"</\", tag, \">\");\n    }\n\n    // A generic element, can be used to construct any SVG (or HTML) element without children\n    function el(\n        string memory tag,\n        string memory props\n    ) internal pure returns (string memory) {\n        return string.concat(\"<\", tag, \" \", props, \"/>\");\n    }\n\n    // an SVG attribute\n    function prop(\n        string memory key,\n        string memory val\n    ) internal pure returns (string memory) {\n        return string.concat(key, \"=\", '\"', val, '\" ');\n    }\n\n    // formats a CSS variable line. includes a semicolon for formatting.\n    function setCssVar(\n        string memory key,\n        string memory val\n    ) internal pure returns (string memory) {\n        return string.concat(\"--\", key, \":\", val, \";\");\n    }\n\n    // formats getting a css variable\n    function getCssVar(\n        string memory key\n    ) internal pure returns (string memory) {\n        return string.concat(\"var(--\", key, \")\");\n    }\n\n    // formats getting a def URL\n    function getDefURL(string memory id) internal pure returns (string memory) {\n        return string.concat(\"url(#\", id, \")\");\n    }\n\n    // formats generic rgba color in css\n    function rgba(\n        uint256 r,\n        uint256 _g,\n        uint256 b,\n        uint256 a\n    ) internal pure returns (string memory) {\n        string memory formattedA = a < 100\n            ? string.concat(\"0.\", a.toString())\n            : \"1\";\n        return\n            string.concat(\n                \"rgba(\",\n                r.toString(),\n                \",\",\n                _g.toString(),\n                \",\",\n                b.toString(),\n                \",\",\n                formattedA,\n                \")\"\n            );\n    }\n}\n"
    },
    "contracts/shared/storage/facets/AppStorageFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { LibDiamond } from \"../../libraries/LibDiamond.sol\";\n\nimport \"../structs/AppStorage.sol\";\n\ncontract AppStorageFacet {\n    AppStorage internal s;\n\n    function appStorage() internal pure returns (AppStorage storage ds){\n      assembly {\n        ds.slot := 0\n      }\n    }\n\n}\n"
    },
    "contracts/shared/storage/structs/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {EnumerableSet} from \"../../libraries/LibEnumerableSet.sol\";\nimport {UintQueueLibrary} from \"../../libraries/LibUintQueueLibrary.sol\";\nimport {UserType, EquipmentType} from \"./NftStorage.sol\";\n\nusing EnumerableSet for EnumerableSet.UintSet;\nusing UintQueueLibrary for UintQueueLibrary.UintQueue;\n\nstruct User {\n    string userId;\n    uint nftId;\n    address reciveAddress;\n    address delegateEOA;\n    UserType userType;\n    //\n    string refferalId;\n    uint refferalCount;\n}\nstruct DelegateEOA {\n    uint userIndex;\n    string userId;\n    address connectAddress;\n    bool isOwnNFT;\n}\n\nstruct levelInfo {\n    uint level;\n    uint requireExp;\n    uint levelUserCount;\n    uint heartMax;\n}\n\nstruct ElementaNFT {\n    address ownerAddress;\n    address delegateAddress;\n    string nickName;\n    uint grade;\n    uint level;\n    uint exp;\n    uint heartMax;\n    uint heartPoint;\n    uint plusHeartPoint;\n    uint updateHeartTime;\n    uint elementaPoint;\n\n    // uint[10] _gap;\n    // uint[10] equipmentItem;\n}\nstruct ElementaItem {\n    EquipmentType equipmentType;\n    uint itemId;\n    string name;\n    bytes svgUri;\n}\n\nstruct GradeOutline {\n    string animateColors;\n    string stopColor;\n    string animateDuration;\n}\n\n// struct BackGround {\n//     string animateColors;\n//     string stopColor;\n//     string animateDuration;\n// }\n\nstruct AppStorage {\n    mapping(string => address) contracts;\n    mapping(string => User) users;\n    uint globalUserIndex;\n    mapping(string => uint) userIndex;\n    // delegate EOA Info\n    mapping(address => DelegateEOA) delegateEOAs;\n    // NFT Info\n    // nftId(userIndex) => ElementaNFT\n    mapping(uint => ElementaNFT) elementaNFTs;\n    mapping(uint => levelInfo) levelInfos;\n    mapping(address => bool) isDelegateEOA;\n    //\n    // items info\n    mapping(uint => ElementaItem) elementaItems;\n    //\n    // nftId => equipmentType => item info\n    mapping(uint => uint[10]) equipItems;\n    // SVGs\n    // mapping(uint => GradeOutline) gradeOutlines;\n    // mapping(uint => BackGround) backgrounds;\n}\n"
    },
    "contracts/shared/storage/structs/NftStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n// pragma solidity ^0.8.0;\n\nenum EquipmentType {\n    Outline, // grade\n    Background,\n    Head,\n    Eyes,\n    Mouth,\n    Body,\n    Hand,\n    Pet,\n    Badge\n}\n\nenum AbilityType {\n    Luck\n    // ...\n    // ...\n    // ...\n}\n\nenum UserType {\n    Wallet,\n    Telegram,\n    Line\n}\nstruct Inventory {\n    // nft status inventory\n    uint[10] equipmentItem;\n    uint[10] ability;\n}\n\nstruct ElementaItem {\n    EquipmentType equipmentType;\n    uint itemId;\n    string name;\n    bytes uri;\n}\n"
    },
    "contracts/shared/utils/modifiersFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {AppStorage} from \"../storage/facets/AppStorageFacet.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract modifiersFacet {\n    AppStorage internal s;\n\n    modifier onlyAdmin() {\n        LibDiamond.enforceIsContractOwner();\n        _;\n    }\n\n    modifier onlyDelegateEOA() {\n        require(\n            s.delegateEOAs[msg.sender].userIndex != 0,\n            \"ModifiersFacet: not delegate EOA\"\n        );\n        _;\n    }\n\n    modifier onlyEOA(address _address) {\n        uint32 size;\n        assembly {\n            size := extcodesize(_address)\n        }\n        \n        require(size == 0, \"ModifiersFacet: not EOA\");\n        _;\n    }\n}\n"
    },
    "solady/src/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library to encode strings in Base64.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\nlibrary Base64 {\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\n    /// @param noPadding Whether to strip away the padding.\n    function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, false, false)`.\n    function encode(bytes memory data) internal pure returns (string memory result) {\n        result = encode(data, false, false);\n    }\n\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\n    /// Equivalent to `encode(data, fileSafe, false)`.\n    function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }\n\n    /// @dev Decodes base64 encoded `data`.\n    ///\n    /// Supports:\n    /// - RFC 4648 (both standard and file-safe mode).\n    /// - RFC 3501 (63: ',').\n    ///\n    /// Does not support:\n    /// - Line breaks.\n    ///\n    /// Note: For performance reasons,\n    /// this function will NOT revert on invalid `data` inputs.\n    /// Outputs for invalid inputs will simply be undefined behaviour.\n    /// It is the user's responsibility to ensure that the `data`\n    /// is a valid base64 encoded string.\n    function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }\n}\n"
    },
    "solady/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The `length` of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            // Update the free memory pointer to allocate.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end of the memory to calculate the length later.\n            let end := str\n\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Write the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                // Keep dividing `temp` until zero.\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n\n            let length := sub(end, str)\n            // Move the pointer 32 bytes leftwards to make room for the length.\n            str := sub(str, 0x20)\n            // Store the length.\n            mstore(str, length)\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) {\n            return toString(uint256(value));\n        }\n        unchecked {\n            str = toString(uint256(-value));\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n\n            if temp {\n                // Store the function selector of `HexLengthInsufficient()`.\n                mstore(0x00, 0x2194895a)\n                // Revert with (offset, size).\n                revert(0x1c, 0x04)\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Write the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Write the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            // Allocate the memory.\n            mstore(0x40, add(str, 0x20))\n            // Zeroize the slot after the string.\n            mstore(str, 0)\n\n            // Cache the end to calculate the length later.\n            let end := str\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n\n            // Compute the string's length.\n            let strLength := sub(end, str)\n            // Move the pointer and write the length.\n            str := sub(str, 0x20)\n            mstore(str, strLength)\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            str := add(str, 2)\n            mstore(str, 40)\n\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0)\n\n            value := shl(96, value)\n\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Write the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Write the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, all indices of the following operations\n    // are byte (ASCII) offsets, not UTF character offsets.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                // Allocate the memory.\n                mstore(0x40, add(result, add(resultLength, 0x20)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                // Allocate memory for the length and the bytes,\n                // rounded up to a multiple of 32.\n                mstore(0x40, add(result, and(add(resultLength, 0x3f), w)))\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            // Zeroize the slot after the string.\n            mstore(last, 0)\n            // Stores the length.\n            mstore(result, totalLength)\n            // Allocate memory for the length and the bytes,\n            // rounded up to a multiple of 32.\n            mstore(0x40, and(add(last, 0x1f), w))\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `smallString` must be null terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 smallString) internal pure returns (string memory result) {\n        if (smallString == bytes32(0)) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} 1 {} {\n                n := add(n, 1)\n                if iszero(byte(n, smallString)) { break } // Scan for '\\0'.\n            }\n            mstore(result, n)\n            let o := add(result, 0x20)\n            mstore(o, smallString)\n            mstore(add(o, n), 0)\n            mstore(0x40, add(result, 0x40))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`. For small strings up to 32 bytes.\n    /// `b` must be null terminated, or behavior will be undefined.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let x := and(b, add(not(b), 1))\n            let r := or(shl(8, iszero(b)), shl(7, iszero(iszero(shr(128, x)))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            result := gt(eq(mload(a), sub(32, shr(3, r))), shr(r, xor(b, mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            result := mload(0x40)\n            // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(0x40, add(result, 0x40))\n            // Zeroize the length slot.\n            mstore(result, 0)\n            // Store the length and bytes.\n            mstore(add(result, 0x1f), packed)\n            // Right pad with zeroes.\n            mstore(add(add(result, 0x20), mload(result)), 0)\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes of `a` and `b`.\n                    or(\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Grab the free memory pointer.\n            resultA := mload(0x40)\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retSize), 0)\n            // Store the return offset.\n            mstore(retStart, 0x20)\n            // End the transaction, returning the string.\n            return(retStart, retSize)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}